interface ComposerArgument {
  name: string;
  is_required: boolean;
  is_array: boolean;
  description: string;
  default: null | string | Array<string>;
}

interface ComposerOption {
  name: string;
  shortcut: string;
  accept_value: boolean;
  is_value_required: boolean;
  is_multiple: boolean; // not supported by fig
  description: string;
  default: null | boolean; // not supported by fig
}

interface ComposerCommandDefinition {
  arguments: Record<string, ComposerArgument>;
  options: Record<string, ComposerOption>;
}

interface ComposerCommand {
  name: string;
  usage: string[]; // this is actually generated by fig
  description: string;
  help: string; //
  definition: ComposerCommandDefinition;
}

interface ComposerListOutput {
  commands: ComposerCommand[];
}

export const completion: Fig.Spec = {
  name: "composer",
  description: "Composer Command",

  generateSpec: async (context, executeShellCommand) => {
    const jsonList = await executeShellCommand("composer list --format=json");
    const subcommands: Fig.Subcommand[] = [];

    try {
      const data: ComposerListOutput = JSON.parse(jsonList);
      for (const command of data.commands) {
        subcommands.push({
          name: command.name,
          description: command.description,
          icon: "https://getcomposer.org/img/logo-composer-transparent5.png",

          args: Object.keys(command.definition.arguments).map((argKey) => {
            const arg = command.definition.arguments[argKey];
            const argDefault = arg.default
              ? Array.isArray(arg.default)
                ? arg.default[0]
                : arg.default
              : undefined;

            return {
              name: arg.name,
              description: arg.description,
              isOptional: !arg.is_required,
              default: argDefault,
              variadic: arg.is_array,
            };
          }),

          options: Object.keys(command.definition.options).map((optionKey) => {
            const option = command.definition.options[optionKey];
            const names = [option.name];

            const shortCut = option.shortcut;
            if (shortCut.trim().length > 0) {
              names.push(shortCut);
            }

            return {
              name: names,
              description: option.description,
              required: option.is_value_required,
              args: option.accept_value ? {} : undefined,
            };
          }),
        });
      }
    } catch (err) {
      console.error(err);
    }

    return {
      name: "composer",
      subcommands,
    };
  },
};
